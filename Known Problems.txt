Known Problems:
    
        Una regola, non so quale ma mi basterebbe guardare nel report, crea delle task senza outgoing flows a volte. Credo sia la 3.

        I misunderstood rules 1 and 2 and tought rule 1 was only about parallel gateways and rule 2 was only about exclusive gateways



        Aggiustare LA REGOLA 3C:

            ========= Reverse3c ==========
            Alla fine faccio così per la regola 3c.
            Evito solo che si creino coppie di contraddizioni, nel modo che ho già usato.
            Se capita che ci sono dei gateway vuoti, li cancello alla fine.
            Basta che controllo se il gateway split punta a un merge di quelli nuovi, ma come faccio?
            Mi creo una lista di predecessor del primo merge.
            Anzi faccio proprio così direttamente alla fine del programmino:

                ritrovo i miei follower
                ritrovo i predecessor del MP
                Per ogni follower controllo che il suo target diretto non sia incluso nei predecessor.
                Se lo è, li cancello entrambi.
                Fare tutto questo in un metodo a parte che prende come input solo il nuovo parallel split e il MP.


TODO:

        HIGH PRIORITY:
    
            Se ci sono due lanes, ci sono anche due processi. Considerare questa cosa, è importante, credo che rompi qualcosa, probabilmente devo aggiungere un for loop e in model avere un array di processi invece che un field per il processo.

        LOW PRIORITY:

            Fare metodo in Model public Element getFirstMeetingPoint(Element e) which returns the first MP of an element. If used in certain rules it could simplify the code. And it should be really simple.

            Fare overload metodo per creare nuovi sequenceFlow con già un certo target e una certa source al momento della creazione. Basta chiamare il metodo standard per creare flow, poi setSource e setTarget. 

            Metti lista Resulting model lista allínizio del report.
            Testare come funziona con i subProcesses. Non dovrebbe rompere niente per come sono scritti, non verranno riconosciuti come task però a meno che non aggiungo un OR, ma non so se è corretto trattarle come task, probabilmente è meglio lasciare così.
       
            Cambiare naming metodi e commenti e variables da 'split' a 'fork', e da 'merge' a 'join'.
        
            Testare come funziona con i subProcesses. Non dovrebbe rompere niente per come sono scritti, non verranno riconosciuti come task però a meno che non aggiungo un OR. Ma forse è un bene che non vengano riconosciuti come task.

            Cosa succede se invece dello start event normale c'è un message event ad esempio o altri tipi di start?
            Ho provato e non succede niente, sono child elements che lo definiscono, quindi sei a posto.
            Magari metti qualche test dove c'è un start event speciale tanto per fare vedere che il tuo programma funziona lo stesso.

            TODO AGGIUNGI QUESTA COSA NEL PROGRAMMA:
                The software creates a folder inside the locations of the starting models, called "output" plus the date and time of the execution, e.g. \texttt{output 14-12-2018 1626}. If a folder with the same name already exists, for example because the user launched two consecutive executions in less than a minute, a new folder called (1) will be launched  

            Capire perché le label sono al posto giusto anche se io non le modifico mai. Forse le loro coordinate sono relative?

            Il programma non riconosce i folder se non finiscono con '\'

            Provare a vedere come sono scritti i modelli di inubit, e eventualmente aggiungere compatibilità con inubit.

            Aggiungere anche il check che le regole non siano opposte, quelle date dall'utente. Nel main, ma dai all'utente la possibilità di continuare.

            Clean the console.

            Fare in modo che il programma accetti più di un plane e di un process.

            /Users/rubenfolini/BPMNTransformations/tests/TestModels/Rule1/Rule1Classic.bpmn.xml npnr (-1-3-2-r2)
